# 条件分岐の必要性

まずは、以下のプログラムを見てみましょう。
整数を2回だけキーボードから入力して、その値で割り算を行うプログラムです。

- main.cpp

    ```
    #include <iostream>

    int main() {
        int number_1 = 0, number_2 = 0;

        std::cout << "1つ目の整数を入力してください: ";
        std::cin >> number_1;
        std::cout << "2つ目の整数を入力してください: ";
        std::cin >> number_2;

        double number_3 = static_cast<double>(number_1) / number_2;
        std::cout << "1つ目の整数を2つ目の整数で割った値: " << number_3 << '\n';
        return 0;
    }

    ```

一見すると、問題なく動きそうなプログラムですが、2つ目の整数に0を入力するとプログラムが正常に動作しなくなります。
原因は、整数を0で割ろうとしているためで、場合によってはプログラムが強制終了するかもしれません。
「分母が0以外のときは割り算を行い、分母が0のとき何も計算しない。」という処理を加えることでこの問題は解消できそうです。

このように、条件によって処理の内容を変えるようにする必要があるのです。

# 条件と真偽

プログラムの改修を行う前に、C++では条件をどのように扱っているかを解説する必要があります。
C++では、条件を「true（真）」と「false（偽）」の2種類の値で表します。

例えば「変数numberの値が80以上である」という条件があったとします。
もし、numberの値が100であればtrueとなり、75であればfalseとなります。

trueとfalseはbool型の値で、整数型と同じように論理リテラルで初期化や代入が行えます。

- main.cpp

    ```
    #include <iostream>

    int main() {
        bool judge = true;
        std::cout << judge << '\n';
        judge = false;
        std::cout << judge << '\n';
        return 0;
    }

    ```

- 実行結果

    ```
    1
    0
    ```

代入した値がtrueやfalseであるにも関わらず、実行結果は整数値になっています。
これは、trueを1、falseを0として処理を行っているためです。

また、bool型は整数値であるため、int型をbool型に変換することもできます。
この場合、trueを0以外の整数、falseを0と表されます。
表にまとめると以下の通りになります。

| 真偽 | bool型 | int型 |
| :-- | :-- | :-- |
| true | 1 | 0以外の整数 |
| false | 0 | 0 |

# 関係演算子

条件をプログラム上で表現するには、関係演算子というものを使用します。
表にまとめると以下通りです。

| 関係演算子 | trueになる条件 |
| :-- | :-- |
| == | 左辺と右辺が等しい |
| != | 左辺と右辺が異なる |
| > | 左辺より右辺の方が小さい |
| >= | 左辺が右辺以上である |
| < | 左辺より右辺の方が大きい |
| <= | 左辺が右辺以下である |

- =と==の違い

    =は代入であるのに対し、==は等しいという意味の演算子です。
    算数や数学とは異なるため、十分注意する必要があります。

実際に、関係演算子をプログラム上で使用してみましょう。

- main.cpp

    ```
    #include <iostream>

    int main() {
        std::cout << (75 == 100) << '\n';
        std::cout << (75 != 100) << '\n';
        std::cout << (75 > 100) << '\n';
        std::cout << (75 >= 100) << '\n';
        std::cout << (75 < 100) << '\n';
        std::cout << (75 <= 100) << '\n';
        return 0;
    }

    ```

- 実行結果

    ```
    0
    1
    0
    0
    1
    1
    ```

「70 == 100」は、70と100が等しくないことから、0すなわちfalseであることがわかります。
一方「70 != 100」は、1すなわちtrueであることがわかります。

# if文

if文は、条件がtrueであるときにブロック内に記述した文を実行する構文です。
もし条件がfalseであった場合、ブロック内の文は実行されず、次の処理に移ります。
書き方は以下の通りです。

```
if (条件) {
    文; // 条件がtrueのときに実行されます。
}
```

それでは、この章の最初のプログラムを、if文を用いて改良してみましょう。

- main.cpp

    ```
    #include <iostream>

    int main() {
        int number_1 = 0, number_2 = 0;

        std::cout << "1つ目の整数を入力してください: ";
        std::cin >> number_1;
        std::cout << "2つ目の整数を入力してください: ";
        std::cin >> number_2;

        if (number_2 != 0) {
            double number_3 = static_cast<double>(number_1) / number_2;
            std::cout << "1つ目の整数を2つ目の整数で割った値: " << number_3 << '\n';
        }

        return 0;
    }

    ```

- 実行結果1

    ```
    1つ目の整数を入力してください: 12
    2つ目の整数を入力してください: 4
    1つ目の整数を2つ目の整数で割った値: 3
    ```

- 実行結果2

    ```
    1つ目の整数を入力してください: 12
    2つ目の整数を入力してください: 0
    ```

ここでは、分母にあたるnumber_2が0以外であるときに、割り算を行うようにしています。
これにより、数値を0で割ってしまう問題を回避しています。

- ブロックの省略

    ブロック内の文が1つだけの場合、{}を省略することができます。
    ただし、if文がうまく動作しない原因になるため、このような書き方はおすすめしません。

    ```
    #include <iostream>

    int main() {
        int number_1 = 12, number_2 = 4, number_3 = 0;

        // {} が省略されています。
        if (number_2 != 0)
            number_3 = static_cast<double>(number_1) / number_2;

        std::cout << number_3 << '\n';
        return 0;
    }

    ```

# if-else文

if-else文はif文の後に、条件がfalseだったときにブロック内に記述した文を実行する構文、else文を加えた構文です。
書き方は以下の通りです。

```
if (条件) {
    文1; // 条件がtrueのときに実行されます。
} else {
    文2; // 条件がfalseのときに実行されます。
}
```

それでは、先ほどのプログラムをさらに改良してみましょう。

- main.cpp

    ```
    #include <iostream>

    int main() {
        int number_1 = 0, number_2 = 0;

        std::cout << "1つ目の整数を入力してください: ";
        std::cin >> number_1;
        std::cout << "2つ目の整数を入力してください: ";
        std::cin >> number_2;

        if (number_2 != 0) {
            double number_3 = static_cast<double>(number_1) / number_2;
            std::cout << "1つ目の整数を2つ目の整数で割った値: " << number_3 << '\n';
        } else {
            std::cout << "2つ目の整数は0以外を入力してください" << '\n';
        }

        return 0;
    }

    ```

- 実行結果1

    ```
    1つ目の整数を入力してください: 12
    2つ目の整数を入力してください: 4
    1つ目の整数を2つ目の整数で割った値: 3
    ```

- 実行結果2

    ```
    1つ目の整数を入力してください: 12
    2つ目の整数を入力してください: 0
    2つ目の整数は0以外を入力してください
    ```

else文を用いることで、number_2が0のとき0以外の値を入力するよう、メッセージで表示できるようになりました。

このように、if-else文は条件によって、処理を分岐することができるのです。

# else-if文

if-else文は連続して記述することで、さらに処理を分岐することができるようになります。
書き方は以下の通りです。

```
if (条件1) {
    文1;
} else if (条件2) {
    文2;
} else if (条件3) { // いくつでも追加できます。
    文3;
} else { // 必要なければ省略もできます。
    文4;
}
```

なお、else-ifの部分はいくつでも繋げることができ、末尾のelseは必要がなければ省略することもできます。

実際にプログラムでelse-if文の動作を確認してみましょう。

- main.cpp

    ```
    #include <iostream>

    int main() {
        int number = 0;
        std::cout << "数値を入力してください: ";
        std::cin >> number;

        if (number < 10) {
            std::cout << "10未満の値が入力されました" << '\n';
        } else if (number < 20) {
            std::cout << "10以上20未満の値が入力されました" << '\n';
        } else {
            std::cout << "20以上の値が入力されました" << '\n';
        }

        return 0;
    }

    ```

- 実行結果1

    ```
    数値を入力してください: 2
    10未満の値が入力されました
    ```

- 実行結果2

    ```
    数値を入力してください: 15
    10以上20未満の値が入力されました
    ```

- 実行結果3

    ```
    数値を入力してください: 28
    20以上の値が入力されました
    ```

10未満の値を入力した場合、直後のブロックに処理が移り、他のブロックの処理は行われません。
10以上の値を入力した場合、最初のif文の条件ではfalseとなり、次のif文に処理が移ります。
ここで、値が20未満であった場合に、その後のブロックに処理が移り、値が20以上である場合はelse文に対応するブロックに処理が移ります。

# switch文とbreak文

条件に応じて処理を分岐する構文は、if-else文の他にswitch文があります。
書き方は以下の通りです。

```
switch (値) {
case 値1:
    文1; // 値が値1と一致したときに実行されます。
    break;
case 値2:
    文2; // 値が値2と一致したときに実行されます。
    break;
default:
    文; // 値がどれでもないときに実行されます。
    break;
}
```

なお、caseからbreak;までの部分はいくつでも繋げて書くことができ、defaultからbreak;までの部分は必要がなければ省略することができます。
break;はbreak文と呼び、これが実行されるとブロック内の処理を終了して、ブロックの外へ抜けます。

switch文をif-else文で書き換えると以下の通りになります。

```
if (値 == 値1) {
    文1; // 値が値1と一致したときに実行されます。
} else if (値 == 値2) {
    文2; // 値が値2と一致したときに実行されます。
} else {
    文; // 値がどれでもないときに実行されます。
}
```

実際に、以下のプログラムでswitch文の動作を確認してみましょう。

- main.cpp

    ```
    #include <iostream>

    int main() {
        std::cout << "yかnを入力してください: ";
        char input = ' ';
        std::cin >> input;

        switch (input) {
        case 'y':
            std::cout << "yが入力されました" << '\n';
            break;
        case 'n':
            std::cout << "nが入力されました" << '\n';
            break;
        default:
            std::cout << "yかnを入力してください" << '\n';
            break;
        }

        return 0;
    }

    ```

- 実行結果1

    ```
    yかnを入力してください: y
    yが入力されました
    ```

- 実行結果2

    ```
    yかnを入力してください: n
    nが入力されました
    ```

- 実行結果3

    ```
    yかnを入力してください: a
    yかnを入力してください
    ```

もし、break文が抜けていると、switch文がうまく動作しなくなる場合があります。
以下のプログラムでは、switch文のうちbreak文を省略したものです。

- main.cpp

    ```
    #include <iostream>

    int main() {
        std::cout << "yかnを入力してください: ";
        char input = ' ';
        std::cin >> input;

        switch (input) {
        case 'y':
            std::cout << "yが入力されました" << '\n';
        case 'n':
            std::cout << "nが入力されました" << '\n';
        default:
            std::cout << "yかnを入力してください" << '\n';
        }

        return 0;
    }

    ```

- 実行結果

    ```
    yかnを入力してください: y
    yが入力されました
    nが入力されました
    yかnを入力してください
    ```

キーボードにyを入力してEnterを押すと、switch文に書かれた全ての文が実行されてしまい、おかしな動作になっています。
このため、必要に応じてbreak文を記述する必要があるのです。

caseに対応する文は省略することができます。
このため、以下のような書き方も可能になります。

- main.cpp

    ```
    #include <iostream>

    int main() {
        std::cout << "yかnを入力してください: ";
        char input = ' ';
        std::cin >> input;

        switch (input) {
        case 'y':
        case 'n':
            std::cout << "yもしくはnが入力されました" << '\n';
            break;
        default:
            std::cout << "yかnを入力してください" << '\n';
        }

        return 0;
    }

    ```

- 実行結果1

    ```
    yかnを入力してください: y
    yもしくはnが入力されました
    ```

- 実行結果2

    ```
    yかnを入力してください: a
    yかnを入力してください
    ```

case 'y':にはbreak文が存在しないため、case 'n':に対応する文が実行されます。
また、default:では対応する文がブロックの末尾にあるため、break文を省略してもswitch文は正常に動作します。

# 条件演算子

条件演算子とは、3つのオペランドを使用して、条件に応じて代入する値を変える演算子です。
書き方は以下の通りです。

```
変数 = 条件 ? 値1 : 値2;
```

条件演算子をif-else文に書き換えると以下の通りになります。

```
if (条件) {
    変数 = 値1;
} else {
    変数 = 値2;
}
```

実際に、以下のプログラムで条件演算子の動作を確認してみましょう。

- main.cpp

    ```
    #include <iostream>

    int main() {
        int number_1 = 10, number_2 = 20;

        int number_3 = (number_1 < number_2) ? number_1 : number_2;
        /*
        以下のif-else文と同じ
        int number_3;
        if (number_1 < number_2) {
            number_3 = number_1;
        } else {
            number_3 = number_2;
        }
        */
        std::cout << number_3 << '\n';

        return 0;
    }

    ```

- 実行結果

    ```
    10
    ```

number_1とnumber_2の大きさを比較して、number_1の方が小さければnumber_1を、逆であればnumber_2をnumber_3に代入しています。
このように、変数の代入だけを行うif-else文は、条件演算子で簡潔に書き換えることができるのです。

# 論理演算子

最後に、複雑な条件を記述することができる論理演算子について解説しましょう。
論理演算子には以下のようなものがあります。

| 論理演算子 | 意味 | trueになる条件 |
| :-- | :-- | :-- |
| ! | 否 | 右辺がfalse |
| && | かつ | 左辺と右辺が両方ともtrue |
| \|\| | または | 左辺と右辺のどちらかがtrue |

以下のプログラムは、論理演算子を使用した際の一例です。

- main.cpp

    ```
    #include <iostream>

    int main() {
        int number = 0;
        std::cout << "数値を入力してください: ";
        std::cin >> number;

        if (!(number == 0)) {
            std::cout << "0以外の値が入力されました" << '\n';
        } else {
            std::cout << "0が入力されました" << '\n';
        }
        if ((1 <= number) && (number <= 10)) {
            std::cout << "1以上かつ10以下の値が入力されました" << '\n';
        } else {
            std::cout << "1未満または10より大きい値が入力されました" << '\n';
        }
        if ((number < 3) || (8 < number)) {
            std::cout << "3未満または8より大きい値が入力されました" << '\n';
        } else {
            std::cout << "3以上かつ8以下の値が入力されました" << '\n';
        }

        return 0;
    }

    ```

- 実行結果

    ```
    数値を入力してください: 10
    0以外の値が入力されました
    1以上かつ10以下の値が入力されました
    3未満または8より大きい値が入力されました
    ```

!(number == 0)は、numberが0のときにfalseとなり、逆の場合はtrueとなります。
(1 <= number) && (number <= 10)は、numberが1以上かつ10以下のときにtrueとなります。
(number < 3) || (8 < number)は、numberが3未満もしくは8より大きいときにtrueとなります。

- 関係演算子と論理演算子の優先順位

    関係演算子は論理演算子よりも優先順位が高いため、演算子の優先順位を上げるための()を付けなくても正常に動作します。
    ただし、プログラムが読みにくくなるため、敢えて()を付けてわかりやすくしています。

論理演算子を使用することで、if文をより複雑な条件で処理を分岐することができるようになるのです。
